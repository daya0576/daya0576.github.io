---
title: 事务型消息
tags:
---

# 事务:
**核心思想:** 进行一系列的原子操作, 如果有一步失败就回滚, 全部成功就提交.
![](/images/blog/190305_message_queue/15517667737056.jpg)


# 消息
引入消息队列的好处
1. 提高核心链路的吞吐量: 同步 → 异步
2. 降低耦合度
3. 增强系统高可用: 强依赖变为弱依赖
![](/images/blog/190305_message_queue/15517667829965.jpg)


# 引入消息存在的问题
`消息发布者` → `消息队列` → `消息订阅者`
这个世界就是这样, 永远存在 tradeoff, 异步消息带来了好处, 也会新引入新的**不一致的问题**:
1. 发布者做了扣款操作, 但消息队列不可用或者网络问题, 发布者的消息没有正常到达消息队列, 会导致后续消息发送失败, 用户没有收到通知.
2. 发布者的扣款操作回滚了, 消息已经发出, 但用户还是收到扣款通知了.

# 事务型消息
为了解决以上描述的两个需求, 消息队列需要提供一种特殊类型的消息: 消息队列收到消息后不会立刻投递消息到消息订阅者, 而是根据消息发布者应用的数据库事务状态决定消息是否投递. 如果数据库事务提交, 则消息投递到订阅者; 反之则不投递. 此类消息被命名为 "事务型消息".
新增**二阶段**, 消息也可以提交或者回滚. 满足 发布者数据库变更 与 异步消息是否投递到订阅者应用的**一致性**. 具体设计方案如下:
![](/images/blog/190305_message_queue/15517667945733.jpg)


**两个问题:**
1. 为什么先发布消息到消息队列, 再做数据库的会滚操作? 因为如果先做数据的变更再发布消息的时候失败了, 需要会滚数据库事务, 成本太高了.
2. 如果提交消息(确认发布消息)的时候, 消息队列没有收到这个请求怎么办? 新增了事务状态主动回查这么一个操作:![](/images/blog/190305_message_queue/15517668454378.jpg)
3. 我理解事务型消息主要解决了「发布者」→「消息队列」失败导致不一致的问题. 那如果「消息队列」→ 「订阅者」失败或者短信通知服务异常, 导致账单变更了, 但用户收不要通知, 要怎么处理呢?
“消息队列” 会持续投递消息对象到 “订阅者”，直至消息对象被成功消费。对于 “订阅者” 应用系统异常的情况，需要 “订阅者” 修复。










