{{- /* Ripple effect â€“ expanding rings at document bottom, scroll to see */ -}}
<canvas id="ripple-canvas"></canvas>
<style>
#ripple-canvas{
  position:absolute;
  bottom:0;
  left:0;
  width:100%;
  height:200px;
  pointer-events:none;
  filter:blur(0.4px);
}
</style>
<script>
(function(){
  const MAX_RIPPLES    = 20;
  const SPAWN_INTERVAL = 200;
  const MAX_RADIUS     = 70;
  const RIPPLE_LIFE    = 2800;
  const FADE_TOP       = 0.3;

  function isDark(){
    const a = document.body.getAttribute('a');
    if(a === 'dark') return true;
    if(a === 'light') return false;
    return window.matchMedia('(prefers-color-scheme: dark)').matches;
  }
  function ringColor(a){ return isDark() ? 'rgba(180,220,250,' + a + ')' : 'rgba(50,95,145,' + a + ')'; }

  const canvas = document.getElementById('ripple-canvas');
  if(!canvas) return;

  let ctx, W, H, dpr;
  let inited = false, isVisible = false;
  let spawnTimer = null, rafId = null;
  const ripples = [];

  function initCanvas(){
    ctx = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
  }

  function resize(){
    dpr = window.devicePixelRatio || 1;
    W = canvas.clientWidth;
    H = canvas.clientHeight;
    canvas.width  = W * dpr;
    canvas.height = H * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function seed(){
    const now = performance.now();
    for(let i = 0; i < 15; i++){
      ripples.push({
        x: Math.random() * W,
        y: H * 0.2 + Math.random() * H * 0.7,
        born: now - Math.random() * RIPPLE_LIFE * 0.7,
        maxR: 25 + Math.random() * (MAX_RADIUS - 25),
        baseAlpha: 0.25 + Math.random() * 0.35
      });
    }
  }

  function spawnRipple(){
    if(ripples.length >= MAX_RIPPLES) return;
    ripples.push({
      x: Math.random() * W,
      y: H * 0.2 + Math.random() * H * 0.7,
      born: performance.now(),
      maxR: 25 + Math.random() * (MAX_RADIUS - 25),
      baseAlpha: 0.25 + Math.random() * 0.35
    });
  }

  function easeOut(t){ return 1 - (1 - t) * (1 - t); }

  function frame(now){
    if(!isVisible){ rafId = null; return; }
    ctx.clearRect(0, 0, W, H);
    for(let i = ripples.length - 1; i >= 0; i--){
      const r = ripples[i];
      const age = now - r.born;
      if(age > RIPPLE_LIFE){ ripples.splice(i, 1); continue; }
      const t = age / RIPPLE_LIFE;
      const fade = Math.pow(1 - t, 1.5);
      const rx = Math.max(0, easeOut(t) * r.maxR);
      const ry = Math.max(0, rx * 0.35);
      if(rx < 0.5) continue;
      const normY = r.y / H;
      const posFade = normY < FADE_TOP ? normY / FADE_TOP : 1.0;
      const alpha = r.baseAlpha * fade * posFade;
      if(alpha <= 0.01) continue;
      ctx.beginPath();
      ctx.ellipse(r.x, r.y, rx, ry, 0, 0, Math.PI * 2);
      ctx.strokeStyle = ringColor(alpha.toFixed(3));
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }
    rafId = requestAnimationFrame(frame);
  }

  function start(){
    if(!inited){ initCanvas(); seed(); inited = true; }
    if(!spawnTimer) spawnTimer = setInterval(spawnRipple, SPAWN_INTERVAL);
    if(!rafId) rafId = requestAnimationFrame(frame);
  }

  function stop(){
    if(spawnTimer){ clearInterval(spawnTimer); spawnTimer = null; }
    if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
  }

  /* lazy init: only start when canvas enters viewport */
  const observer = new IntersectionObserver(function(entries){
    isVisible = entries[0].isIntersecting;
    if(isVisible) start(); else stop();
  }, { threshold: 0.05 });
  observer.observe(canvas);

  document.addEventListener('visibilitychange', function(){
    if(document.hidden) stop();
    else if(isVisible) start();
  });
})();
</script>