{{- /* Anime-style rain effect – static streaks with shimmer & blur for dreamy motion feel */ -}}
<canvas id="rain-canvas" style="position:absolute;top:0;left:0;width:100%;height:33.4vh;pointer-events:none;z-index:9999;filter:blur(0.5px);"></canvas>
<script>
(function(){
  /* ── tunables ─────────────────────────────────────── */
  const DROP_COUNT    = 120;
  const WIND_ANGLE    = 0.15;    // slight rightward slant
  const MIN_LEN       = 16;
  const MAX_LEN       = 42;
  const LINE_WIDTH    = 1.6;
  const FADE_START    = 0.3;     // fade begins at 30% of canvas
  /* shimmer – each drop pulses alpha with its own phase & speed */
  const SHIMMER_MIN   = 0.08;
  const SHIMMER_MAX   = 0.48;
  const SHIMMER_SPEED_MIN = 0.4; // radians/sec
  const SHIMMER_SPEED_MAX = 1.8;
  /* colour – adaptive to light/dark mode */
  function isDark(){
    const a = document.body.getAttribute('a');
    if(a === 'dark') return true;
    if(a === 'light') return false;
    return window.matchMedia('(prefers-color-scheme: dark)').matches;
  }
  function dropColor(){ return isDark() ? 'rgba(180,210,240,' : 'rgba(80,100,130,'; }

  const canvas = document.getElementById('rain-canvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');

  let W, H, dpr;
  function resize(){
    dpr = window.devicePixelRatio || 1;
    W = canvas.clientWidth;
    H = canvas.clientHeight;
    canvas.width  = W * dpr;
    canvas.height = H * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // regenerate drops on resize
    drops = makeDrops();
  }
  window.addEventListener('resize', resize);

  const cosA = Math.cos(WIND_ANGLE), sinA = Math.sin(WIND_ANGLE);

  /* ── static drop pool ────────────────────────────── */
  function makeDrops(){
    const arr = [];
    for(let i = 0; i < DROP_COUNT; i++){
      const len = MIN_LEN + Math.random() * (MAX_LEN - MIN_LEN);
      const x   = Math.random() * (W + 60) - 30;
      const y   = Math.random() * H * 1.1;       // spread across canvas
      arr.push({
        x1: x,
        y1: y,
        x2: x - sinA * len,
        y2: y - cosA * len,
        width: 0.6 + Math.random() * (LINE_WIDTH - 0.6),
        /* shimmer params */
        phase: Math.random() * Math.PI * 2,
        speed: SHIMMER_SPEED_MIN + Math.random() * (SHIMMER_SPEED_MAX - SHIMMER_SPEED_MIN),
        baseAlpha: SHIMMER_MIN + Math.random() * (SHIMMER_MAX - SHIMMER_MIN),
        /* positional fade */
        posFade: 1.0
      });
      // pre-compute positional fade
      const d = arr[arr.length - 1];
      const fadeY = Math.max(d.y1, 0) / H;
      d.posFade = fadeY < FADE_START ? 1.0
                : Math.max(0, 1.0 - (fadeY - FADE_START) / (1.0 - FADE_START));
    }
    return arr;
  }

  let drops = [];
  resize();

  /* ── animation: only alpha shimmer, positions stay fixed ── */
  function frame(ts){
    const sec = ts / 1000;
    ctx.clearRect(0, 0, W, H);

    for(let i = 0; i < drops.length; i++){
      const d = drops[i];
      if(d.posFade <= 0.01) continue;

      /* sine shimmer: smoothly oscillate alpha */
      const shimmer = 0.5 + 0.5 * Math.sin(sec * d.speed + d.phase);
      const alpha   = (SHIMMER_MIN + shimmer * (d.baseAlpha - SHIMMER_MIN)) * d.posFade;

      ctx.beginPath();
      ctx.moveTo(d.x1, d.y1);
      ctx.lineTo(d.x2, d.y2);
      ctx.strokeStyle = dropColor() + alpha.toFixed(3) + ')';
      ctx.lineWidth   = d.width;
      ctx.lineCap     = 'round';
      ctx.stroke();
    }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>